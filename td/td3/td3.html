<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TD3: Classification hiérarchique ascendante</title>
<meta name="author" content="Roland Donat" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="https://roland-donat.github.io/ubs/Charte_graphique/IUT/ubs_iut_vannes.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">TD3: Classification hiérarchique ascendante</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table des matières</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgd6e69da">Introduction</a></li>
<li><a href="#orgcdaa924">Modules <code>Python</code> utilisés dans ce TD</a></li>
<li><a href="#org9f51611">Exercice 1 : CAH et données <code>wine</code></a>
<ul>
<li><a href="#org8af40ce">Chargement des données</a></li>
<li><a href="#orgaf936c3">CAH avec paramètres par défaut</a></li>
<li><a href="#orge0e0d32">Influence de la distance entre groupe</a></li>
</ul>
</li>
<li><a href="#orgebe2945">Exercice 2 : Analyse de profils d'équipes de football</a>
<ul>
<li><a href="#org1be8df8">Préparation des données</a></li>
<li><a href="#org2f58df0">Détection de profils</a></li>
</ul>
</li>
<li><a href="#org302b768">Exercice 3 : Programmation des distances entre classes</a></li>
</ul>
</div>
</div>

<div id="orge73425f" class="figure">
<p><img src="./woman_soccer_bet.png" alt="woman_soccer_bet.png" width="50%" />
</p>
<p><span class="figure-number">Figure&nbsp;1&nbsp;: </span><i>A woman datascientist performing machine learning to bet on soccer teams, manga style</i> (source: générée par <a href="https://openai.com/dall-e-2/">DALL-E</a>)</p>
</div>

<div id="outline-container-orgd6e69da" class="outline-2">
<h2 id="orgd6e69da">Introduction</h2>
<div class="outline-text-2" id="text-orgd6e69da">
<p>
Dans ce dernier TD, nous mettrons en pratique la méthode de classification ascendante hiérarchique
(CAH) sur différents jeux de données afin d'en évaluer les propriétés.
</p>

<p>
Ce TD aura également pour objectif de comparer les approches de classification non supervisées vues
en cours dans le cadre d'applications pratiques.
</p>

<p>
Enfin, une activité de programmation de distances entre classes est proposée afin de monter en
compétence sur le langage <code>Python</code>.
</p>
</div>
</div>

<div id="outline-container-orgcdaa924" class="outline-2">
<h2 id="orgcdaa924">Modules <code>Python</code> utilisés dans ce TD</h2>
<div class="outline-text-2" id="text-orgcdaa924">
<p>
Dans ce TD, nous utiliserons les modules <code>Python</code> suivants :
</p>
<ul class="org-ul">
<li><code>pandas</code>, pour la manipulation des données ;</li>
<li><code>plotly</code>, pour les représentations graphiques ;</li>
<li><code>numpy</code>, pour utiliser des fonctions de calculs numériques "bas niveau", e.g. génération de
nombres aléatoires ;</li>
<li><code>scipy</code>, pour utiliser d'autres fonctions de calculs numériques plus "haut niveau", e.g. calcul de
distances ;</li>
<li><code>sklearn</code>, pour les algorithmes de <i>machine learning</i> (k-<i>Means</i>, mélange gaussien, ou autres).</li>
</ul>

<p>
Ces modules ne sont pas forcément installés dans votre environnement local ou distant. Vous pouvez
donc utiliser la commande <code>!pip install &lt;nom_module&gt;</code> pour les installer : 
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!pip install pandas</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!pip install plotly</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!pip install scipy</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!pip install scikit-learn</span>
</pre>
</div>


<p>
Rappel : code d'import des modules :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> pandas <span style="color: #F0DFAF; font-weight: bold;">as</span> pd                   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Manipulation des donn&#233;es</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> np                    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul num&#233;rique</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> plotly <span style="color: #F0DFAF; font-weight: bold;">as</span> pl                   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Librairie principale pour avoir le n&#176; de version</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> plotly.express <span style="color: #F0DFAF; font-weight: bold;">as</span> px           <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package plotly pour utiliser les visualisations de haut niveau</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> plotly.figure_factory <span style="color: #F0DFAF; font-weight: bold;">as</span> pff   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package plotly pour utiliser d'autres visualisations de haut niveau plus exotiques (e.g. dendrogramme)</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> plotly.io <span style="color: #F0DFAF; font-weight: bold;">as</span> pio               <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">N&#233;cessaire avec Spyder</span>
<span style="color: #DFAF8F;">pio.renderers.default</span> = <span style="color: #CC9393;">'browser'</span>     <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">N&#233;cessaire avec Spyder</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> sklearn <span style="color: #F0DFAF; font-weight: bold;">as</span> sk                  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Librairie principale pour avoir le n&#176; de version</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> sklearn.cluster <span style="color: #F0DFAF; font-weight: bold;">as</span> skc         <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package sklearn d&#233;di&#233; au clustering</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> sklearn.mixture <span style="color: #F0DFAF; font-weight: bold;">as</span> skm         <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package sklearn d&#233;di&#233; aux mod&#232;les de m&#233;lange</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> sklearn.decomposition <span style="color: #F0DFAF; font-weight: bold;">as</span> skd   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package sklearn d&#233;di&#233; aux m&#233;thodes factorielles</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> scipy <span style="color: #F0DFAF; font-weight: bold;">as</span> sc                    <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Librairie principale de calcul num&#233;rique avanc&#233;e</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> scipy.cluster.hierarchy <span style="color: #F0DFAF; font-weight: bold;">as</span> sch <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package scipy d&#233;di&#233; au clustering hi&#233;rarchique</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> scipy.spatial.distance <span style="color: #F0DFAF; font-weight: bold;">as</span> scd  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package scipy d&#233;di&#233; au clacul de distance</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">V&#233;rification des versions des librairies utilis&#233;es</span>
{<span style="color: #CC9393;">"plotly"</span>: pl.__version__, 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #CC9393;">"pandas"</span>: pd.__version__, 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #CC9393;">"numpy"</span>: np.__version__,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #CC9393;">"sklearn"</span>: sk.__version__,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #CC9393;">"scipy"</span>: sc.__version__}
</pre>
</div>
</div>
</div>


<div id="outline-container-org9f51611" class="outline-2">
<h2 id="org9f51611">Exercice 1 : CAH et données <code>wine</code></h2>
<div class="outline-text-2" id="text-org9f51611">
<p>
Dans cet exercice, nous reprenons les données <code>wine</code> afin d'y appliquer différentes CAH dans le but
d'identifier des profils de vignobles.
</p>
</div>

<div id="outline-container-org8af40ce" class="outline-3">
<h3 id="org8af40ce">Chargement des données</h3>
<div class="outline-text-3" id="text-org8af40ce">
<ol class="org-ol">
<li><p>
Chargez les données <code>Wine</code> dans un <code>DataFrame</code> nommé <code>wine_ori_df</code> (<code>ori</code> pour originales).
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">wine_path</span> = <span style="color: #CC9393;">"https://roland-donat.github.io/cours-class-non-sup/td/td1/wine.csv"</span>
<span style="color: #DFAF8F;">wine_ori_df</span> = pd.read_csv(wine_path, sep=<span style="color: #CC9393;">","</span>)
</pre>
</div></li>

<li><p>
Centrer et réduire les données afin d'obtenir un nouveau DataFrame <code>wine_cr_df</code> (<code>cr</code> pour
centré-réduit).
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">wine_cr_df</span> = (wine_ori_df - wine_ori_df.mean())/wine_ori_df.std()
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-orgaf936c3" class="outline-3">
<h3 id="orgaf936c3">CAH avec paramètres par défaut</h3>
<div class="outline-text-3" id="text-orgaf936c3">
<p>
Nous allons utiliser l'algorithme CAH afin de construire une hiérarchie sur nos vins à
partir de leurs caractéristiques physico-chimiques. Pour ce faire, le package <code>sklearn.cluster</code> (ou
<code>skc</code> pour nous) de la librairie <code>sklearn</code> propose une implémentation de l'algorithme CAH dans
la classe <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering"><code>skc.AgglomerativeClustering</code></a>.
</p>

<ol class="org-ol">
<li><p>
Construire un modèle CAH avec la classe
<a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering"><code>skc.AgglomerativeClustering</code></a> en utilisant les
paramètres par défaut.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">cah_cr_def</span> = skc.AgglomerativeClustering()
</pre>
</div></li>

<li><p>
Utiliser ensuite la méthode <code>fit</code> pour construire la hiérarchie sur les données <code>wine_cr_df</code> :
</p>
<div class="org-src-container">
<pre class="src src-python">cah_cr_def.fit(wine_cr_df)
</pre>
</div></li>

<li><p>
Explorer l'objet <code>cah_cr_def</code> et déterminer la signification des attributs suivants :
</p>
<div class="org-src-container">
<pre class="src src-python">cah_cr_def.n_clusters_
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">cah_cr_def.labels_
</pre>
</div>
<div class="org-src-container">
<pre class="src src-python">cah_cr_def.n_leaves_
</pre>
</div></li>

<li><p>
Décrire les profils obtenus avec la partition du modèle <code>cah_cr_def</code> (diagramme en paires,
boxplot, profils statistiques détaillés).
</p>
<div class="org-src-container">
<pre class="src src-python">px.scatter_matrix(wine_ori_df,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> color=cah_cr_def.labels_.astype(<span style="color: #DCDCCC; font-weight: bold;">str</span>), 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> title=<span style="color: #CC9393;">"Partition cah_cr_def"</span>)
px.box(wine_ori_df, color=cah_cr_def.labels_.astype(<span style="color: #DCDCCC; font-weight: bold;">str</span>),
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>  title=<span style="color: #CC9393;">"Profils des groupes obtenus par la classification cah_cr_def"</span>).show()
<span style="color: #DFAF8F;">cah_def_ori_prof</span> = \
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   wine_ori_df.groupby(cah_cr_def.labels_).describe()
</pre>
</div></li>

<li>Que peut-on dire du comportement par défaut de la classe <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering"><code>skc.AgglomerativeClustering</code></a> en termes,
de partitionnement réalisé, de distance entre individus et entre groupes utilisée ?</li>

<li><p>
Calculer l'inertie expliquée par la partition <code>cah_cr_def</code>. <b>Aide :</b> Utiliser la fonction
<code>eval_partition</code> du <a href="../td2/td2.html">TD2</a>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">eval_partition</span>(data_df, partition):
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #9FC59F;">"""</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;">   Entr&#233;es :</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;">   - data_df (pandas.DataFrame) : Donn&#233;es quantitatives</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;">   - partition (list, numpy.array ou pandas.Series) : partition des donn&#233;es</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;">   Sortie :</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;">   - inertie_intra : inertie intra-classe de la partition</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;">   - inertie_score : Inertie expliqu&#233;e par la partition entre 0 et 1</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;">   """</span>

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul de l'inertie totale des donn&#233;es (cf. TD1)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">mu_data</span> = data_df.mean()
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">d2_data_mu</span> = ((data_df - mu_data)**2).<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">inertie_totale</span> = d2_data_mu.<span style="color: #DCDCCC; font-weight: bold;">sum</span>()

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul de l'inertie interne aux classes (cf. TD1)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">inertie_intra</span> = 0
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">for</span> cls, data_cls_df <span style="color: #F0DFAF; font-weight: bold;">in</span> data_df.groupby(partition):
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Centre de gravit&#233; de la classe cls</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">mu_cls</span> = data_cls_df.mean()
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Distances au carr&#233; entre les donn&#233;es de la classe et le centre de la classe</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">d2_data_cls</span> = ((data_cls_df - mu_cls)**2).<span style="color: #DCDCCC; font-weight: bold;">sum</span>(axis=1)
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Sommation pour obtenir l'inertie interne &#224; la classe</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">inertie_intra</span> += d2_data_cls.<span style="color: #DCDCCC; font-weight: bold;">sum</span>()
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Inertie expliqu&#233;e par la partition</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">inertie_score</span> = 1 - inertie_intra/inertie_totale

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> inertie_intra, inertie_score

<span style="color: #DFAF8F;">cah_cr_def_iw</span>, <span style="color: #DFAF8F;">cah_cr_def_ie</span> = eval_partition(wine_cr_df, cah_cr_def.labels_)
</pre>
</div></li>

<li>Étudier l'aide de la classe <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.AgglomerativeClustering.html#sklearn.cluster.AgglomerativeClustering"><code>AgglomerativeClustering</code></a> afin de comprendre le rôle des
principaux paramètres de la classe, à savoir <code>n_clusters</code>, <code>metric</code> et <code>lingkage</code>.</li>

<li>Construire une nouvelle hiérarchie <code>cah_cr_ward</code> sur les données <code>wine_cr</code> afin de produire une partition en 3
groupes en utilisant la distance de Ward.</li>
<li>Décrire les profils obtenus avec la partition du modèle <code>cah_cr_ward</code> (diagramme en paires,
boxplot, profils statistiques détaillés).</li>
<li><p>
Construire le dendrogramme de la CAH sur les données <code>wine_cr_df</code> réalisée en utilisant la
distance de Ward. Pour ce faire, utiliser la fonction <code>create_dendrogram</code> du package
<code>plotly.figure_factory</code> (ou <code>plf</code> pour nous).
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">cah_cr_ward_dendro_fig</span> = \
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   pff.create_dendrogram(wine_cr_df,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> labels=wine_cr_df.index,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> color_threshold=15,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> linkagefun=<span style="color: #F0DFAF; font-weight: bold;">lambda</span> x: sch.linkage(x, <span style="color: #CC9393;">"ward"</span>))

cah_cr_ward_dendro_fig.update_layout(
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   title_text=f<span style="color: #CC9393;">"CAH avec distance d'aggr&#233;gation Ward et distance entre individus euclidienne"</span>,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   width=1600, height=900)
</pre>
</div></li>
</ol>
</div>
</div>


<div id="outline-container-orge0e0d32" class="outline-3">
<h3 id="orge0e0d32">Influence de la distance entre groupe</h3>
<div class="outline-text-3" id="text-orge0e0d32">
<p>
Dans cette section, nous allons observer l'influence de la distance entre groupe dans le processus
de construction de la CAH.
</p>

<ol class="org-ol">
<li><p>
Construire une CAH <code>cah_cr_single</code> sur les données <code>wine_cr</code> afin de produire une partition en 3
groupes en utilisant la distance du lien minimum (<i>single link</i>).
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">cah_cr_single</span> = skc.AgglomerativeClustering(
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   n_clusters=3,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   linkage=<span style="color: #CC9393;">"single"</span>).fit(wine_cr_df)
</pre>
</div></li>

<li>Calculer l'inertie expliquée par la partition <code>cah_cr_single</code>.</li>
<li>Décrire les profils obtenus avec la partition du modèle <code>cah_cr_single</code> (diagramme en paires,
boxplot, profils statistiques détaillés).</li>
<li>Construire le dendrogramme de la CAH sur les données <code>wine_cr_df</code> réalisée en utilisant la
distance du lien minimum.</li>
<li>Interpréter les résultats obtenus.</li>

<li>Faire une CAH sur les données <code>wine_cr_df</code> en réalisant les mêmes analyses que précédemment mais
en utilisant la distance du lien maximum (<i>complete link</i>). Le modèle CAH sera nommé
<code>cah_cr_complete</code>. Comparer les résultats obtenus avec les CAH précédentes.</li>
<li>Faire une CAH sur les données <code>wine_cr_df</code> en réalisant les mêmes analyses que précédemment mais
en utilisant la distance du lien moyen (<i>average link</i>). Le modèle CAH sera nommé
<code>cah_cr_average</code>. Comparer les résultats obtenus avec les CAH précédentes.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgebe2945" class="outline-2">
<h2 id="orgebe2945">Exercice 2 : Analyse de profils d'équipes de football</h2>
<div class="outline-text-2" id="text-orgebe2945">
<p>
Dans cet exercice, nous allons travailler sur des données historiques de matchs de football. Les
données couvrent les deux premières divisions de différents championnats européens.
</p>

<p>
Le Tableau <a href="#org6cab2e2">1</a> donne une description des variables du jeu de
données. 
</p>

<table id="org6cab2e2" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Tableau 1 :</span> Définition des variables des du jeu de données.</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Colonne</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">league_id</td>
<td class="org-left">Identifiant du championnat</td>
</tr>

<tr>
<td class="org-left">season_id</td>
<td class="org-left">Identifiant de la saison</td>
</tr>

<tr>
<td class="org-left">Date</td>
<td class="org-left">Date du match au format %Y-%m-%d</td>
</tr>

<tr>
<td class="org-left">HomeTeam</td>
<td class="org-left">Équipe à domicile (ED)</td>
</tr>

<tr>
<td class="org-left">AwayTeam</td>
<td class="org-left">Équipe à l'exterieur (EE)</td>
</tr>

<tr>
<td class="org-left">FTHG</td>
<td class="org-left">Nombre de buts de l'ED à la fin du match</td>
</tr>

<tr>
<td class="org-left">FTAG</td>
<td class="org-left">Nombre de buts de l'EE à la fin du match</td>
</tr>

<tr>
<td class="org-left">FTR</td>
<td class="org-left">Résultat à la fin du match (H = ED gagne, D = match nul, A = EE gagne)</td>
</tr>

<tr>
<td class="org-left">HTHG</td>
<td class="org-left">Nombre de buts de l'ED à la mi-temps</td>
</tr>

<tr>
<td class="org-left">HTAG</td>
<td class="org-left">Nombre de buts de l'EE à la mi-temps</td>
</tr>

<tr>
<td class="org-left">HTR</td>
<td class="org-left">Résultat à la mi-temps (H = ED gagne, D = match nul, A = EE gagne)</td>
</tr>

<tr>
<td class="org-left">HS</td>
<td class="org-left">Nombre de tirs tentés par l'ED</td>
</tr>

<tr>
<td class="org-left">AS</td>
<td class="org-left">Nombre de tirs tentés par l'EE</td>
</tr>

<tr>
<td class="org-left">HST</td>
<td class="org-left">Nombre de tirs cadrés par l'ED</td>
</tr>

<tr>
<td class="org-left">AST</td>
<td class="org-left">Nombre de tirs cadrés par l'EE</td>
</tr>

<tr>
<td class="org-left">HC</td>
<td class="org-left">Nombre de corners pour l'ED</td>
</tr>

<tr>
<td class="org-left">AC</td>
<td class="org-left">Nombre de corners pour l'EE</td>
</tr>

<tr>
<td class="org-left">HF</td>
<td class="org-left">Nombre de fautes commises par l'ED</td>
</tr>

<tr>
<td class="org-left">AF</td>
<td class="org-left">Nombre de fautes commises par l'EE</td>
</tr>

<tr>
<td class="org-left">HY</td>
<td class="org-left">Nombre de cartons jaunes reçus par l'ED</td>
</tr>

<tr>
<td class="org-left">AY</td>
<td class="org-left">Nombre de cartons jaunes reçus par l'EE</td>
</tr>

<tr>
<td class="org-left">HR</td>
<td class="org-left">Nombre de cartons rouges reçus par l'ED</td>
</tr>

<tr>
<td class="org-left">AR</td>
<td class="org-left">Nombre de cartons rouges reçus par l'EE</td>
</tr>
</tbody>
</table>

<p>
L'objectif est d'identifier des profils d'équipes à partir des méthodes de classification non
supervisées vues en cours.
</p>
</div>

<div id="outline-container-org1be8df8" class="outline-3">
<h3 id="org1be8df8">Préparation des données</h3>
<div class="outline-text-3" id="text-org1be8df8">
<ol class="org-ol">
<li><p>
Charger les données à partir de l'adresse suivante :
<a href="https://roland-donat.github.io/cours-class-non-sup/td/td3/data_soccer_fixtures.csv">https://roland-donat.github.io/cours-class-non-sup/td/td3/data_soccer_fixtures.csv</a>. Le séparateur
est ";".
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">soccer_path</span> = <span style="color: #CC9393;">"https://roland-donat.github.io/cours-class-non-sup/td/td3/data_soccer_fixtures.csv"</span>
<span style="color: #DFAF8F;">soccer_df</span> = pd.read_csv(soccer_path, sep=<span style="color: #CC9393;">";"</span>)
soccer_df.head()
</pre>
</div></li>

<li><p>
Faire une extraction des données de la division 1 française (<code>league_id = fra_l1</code>) sur la saison
2018-2019.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">idx_selection</span> = (soccer_df[<span style="color: #CC9393;">"league_id"</span>] == <span style="color: #CC9393;">"fra_l1"</span>) &amp; (soccer_df[<span style="color: #CC9393;">"season_id"</span>] == <span style="color: #CC9393;">"2018-2019"</span>)
<span style="color: #DFAF8F;">soccer_sel_df</span> = soccer_df.loc[idx_selection]
soccer_sel_df.head()
</pre>
</div></li>

<li><p>
Sélectionner les données des équipes à domicile, i.e. <code>['HomeTeam', 'FTHG', 'HTHG', 'HS', 'HST',
   'HC', 'HF', 'HY', 'HR']</code>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">col_selection</span> = [<span style="color: #CC9393;">'HomeTeam'</span>, <span style="color: #CC9393;">'FTHG'</span>, <span style="color: #CC9393;">'HTHG'</span>, <span style="color: #CC9393;">'HS'</span>, <span style="color: #CC9393;">'HST'</span>, <span style="color: #CC9393;">'HC'</span>, <span style="color: #CC9393;">'HF'</span>, <span style="color: #CC9393;">'HY'</span>, <span style="color: #CC9393;">'HR'</span>]
<span style="color: #DFAF8F;">soccer_sel_df</span> = soccer_sel_df[col_selection]
soccer_sel_df.head()
</pre>
</div></li>

<li><p>
Regrouper les données par équipe et calculer la moyenne des faits de jeu par équipe.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">soccer_mean_df</span> = soccer_sel_df.groupby(<span style="color: #CC9393;">"HomeTeam"</span>).mean()
soccer_mean_df
</pre>
</div></li>
</ol>
</div>
</div>

<div id="outline-container-org2f58df0" class="outline-3">
<h3 id="org2f58df0">Détection de profils</h3>
<div class="outline-text-3" id="text-org2f58df0">
<ol class="org-ol">
<li>Réaliser une CAH sur les données <code>soccer_mean_df</code> avec la distance de Ward afin de partitionner
les équipes en 4 groupes. Essayer d'interpréter les groupes obtenus.</li>
<li>Appliquer la
méthode du coude afin d'évaluer un compromis entre nombre de classes et inertie expliquée.</li>
<li>Refaire les traitements précédents en utilisant la méthode des moyennes mobiles. Comparer les
résultats obtenus.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org302b768" class="outline-2">
<h2 id="org302b768">Exercice 3 : Programmation des distances entre classes</h2>
<div class="outline-text-2" id="text-org302b768">
<p>
Cet exercice a pour objectif de vous faire programmer les différentes distances entre classes vues
en cours. Vous développerez ainsi des fonctions ayant la forme suivante :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">calcul_</span>&lt;nom distance&gt;(data_df1, data_df2):
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Votre code &#224; mettre ici</span>

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #F0DFAF; font-weight: bold;">return</span> dist
</pre>
</div>
<p>
Remarques :
</p>
<ul class="org-ul">
<li><code>&lt;nom_distance&gt;</code> est à remplacer par le nom de la distance programmée.</li>
<li><code>data_df1</code> et <code>data_df2</code> sont deux <code>DataFrame</code> contenant les individus de deux classes disjointes.</li>
<li>La fonction retourne la valeur de la distance calculée.</li>
<li>Vous supposerez que la distance entre individus est la distance euclidienne.</li>
</ul>

<p>
Le travail consiste alors à créer les quatre fonctions suivantes :
</p>
<ol class="org-ol">
<li><code>calcul_single</code> qui calcule la distance du lien minimum.</li>
<li><code>calcul_complete</code> qui calcule la distance du lien maximum.</li>
<li><code>calcul_average</code> qui calcule la distance moyenne.</li>
<li><code>calcul_ward</code> qui calcule la distance de Ward.</li>
</ol>

<p>
<b>Aide :</b> vous pouvez utiliser la fonction <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html"><code>cdist</code></a> du package <code>scipy.spatial.distance</code>.
</p>
</div>
</div>
</div>
</body>
</html>
