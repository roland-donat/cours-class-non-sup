<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TD2: Méthodes de partitionnement</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Roland Donat" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<link rel="stylesheet" type="text/css" href="https://roland-donat.github.io/ubs/Charte_graphique/IUT/ubs_iut_vannes.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">TD2: Méthodes de partitionnement</h1>
<div id="table-of-contents">
<h2>Table des matières</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9e0141e">Introduction</a></li>
<li><a href="#orge122269">Modules <code>Python</code> utilisés dans ce TD</a></li>
<li><a href="#org6038075">Exercice 1 : Données <code>Wine</code></a>
<ul>
<li><a href="#orgcfb4276">Préparation des données</a></li>
<li><a href="#org0e4c8af">Moyennes mobiles</a></li>
<li><a href="#orgc229302">Mélange gaussien</a></li>
</ul>
</li>
<li><a href="#org3f30fb0">Exercice 2 : Données synthétiques</a>
<ul>
<li><a href="#org8a59c2f">Données circulaires</a></li>
<li><a href="#org4baddc1">Données elliptiques</a></li>
</ul>
</li>
<li><a href="#org618a8a9">Exercice 3 : Implémentation des moyennes mobiles</a></li>
</ul>
</div>
</div>

<div id="outline-container-org9e0141e" class="outline-2">
<h2 id="org9e0141e">Introduction</h2>
<div class="outline-text-2" id="text-org9e0141e">
<p>
L'objectif de ce TD est d'expérimenter les méthodes de partitionnement vues en cours, à savoir la
méthode des moyennes mobiles (k-<i>Means</i>) et la méthode du mélange gaussien. 
</p>

<p>
Nous testerons ces méthodes avec différents jeux de données afin d'illustrer leurs propriétés
caractéristiques. 
</p>

<p>
Enfin, nous tenterons d'implémenter notre propre version de l'algorithme k-<i>Means</i> en <code>Python</code>.
</p>
</div>
</div>

<div id="outline-container-orge122269" class="outline-2">
<h2 id="orge122269">Modules <code>Python</code> utilisés dans ce TD</h2>
<div class="outline-text-2" id="text-orge122269">
<p>
Dans ce TD, nous utiliserons les modules <code>Python</code> suivants :
</p>
<ul class="org-ul">
<li><code>pandas</code>, pour la manipulation des données ;</li>
<li><code>plotly</code>, pour les représentations graphiques ;</li>
<li><code>numpy</code>, pour utiliser des fonctions de calculs numériques "bas niveau", e.g. génération de
nombres aléatoires ;</li>
<li><code>sklearn</code>, pour les algorithmes de <i>machine learning</i> (k-<i>Means</i>, mélange gaussien, ou autres).</li>
</ul>

<p>
Ces modules ne sont pas forcément installés dans votre environnement local ou distant. Vous pouvez
donc utiliser la commande <code>!pip install &lt;nom_module&gt;</code> pour les installer : 
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&#192; d&#233;commenter si besoin</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!pip install pandas=='1.1.5'</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!pip install plotly=='4.14.3'</span>
<span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!pip install scikit-learn=='0.24.1'</span>
</pre>
</div>


<p>
Rappel : code d'import des modules :
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">import</span> pandas <span style="color: #F0DFAF; font-weight: bold;">as</span> pd  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Manipulation des donn&#233;es</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> numpy <span style="color: #F0DFAF; font-weight: bold;">as</span> np <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul num&#233;rique</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> plotly <span style="color: #F0DFAF; font-weight: bold;">as</span> pl <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Librairie principale pour avoir le n&#176; de version</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> plotly.express <span style="color: #F0DFAF; font-weight: bold;">as</span> px <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package plotly pour utiliser les visualisations de haut niveau</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> sklearn <span style="color: #F0DFAF; font-weight: bold;">as</span> sk <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Librairie principale pour avoir le n&#176; de version</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> sklearn.cluster <span style="color: #F0DFAF; font-weight: bold;">as</span> skc <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package sklearn d&#233;di&#233; au clustering</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> sklearn.mixture <span style="color: #F0DFAF; font-weight: bold;">as</span> skm <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package sklearn d&#233;di&#233; aux mod&#232;les de m&#233;lange</span>
<span style="color: #F0DFAF; font-weight: bold;">import</span> sklearn.decomposition <span style="color: #F0DFAF; font-weight: bold;">as</span> skd   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Package sklearn d&#233;di&#233; aux m&#233;thodes factorielles</span>

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">V&#233;rification des versions des librairies utilis&#233;es</span>
{<span style="color: #CC9393;">"plotly"</span>: pl.__version__, 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #CC9393;">"pandas"</span>: pd.__version__, 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #CC9393;">"numpy"</span>: np.__version__, 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #CC9393;">"sklearn"</span>: sk.__version__}
</pre>
</div>
</div>
</div>


<div id="outline-container-org6038075" class="outline-2">
<h2 id="org6038075">Exercice 1 : Données <code>Wine</code></h2>
<div class="outline-text-2" id="text-org6038075">
<p>
Nous allons reprendre les données des analyses chimiques sur le vin. Les données sont
<a href="https://roland-donat.github.io/cours-class-non-sup/td/td2/wine.csv">disponibles à ici</a>.
</p>
</div>

<div id="outline-container-orgcfb4276" class="outline-3">
<h3 id="orgcfb4276">Préparation des données</h3>
<div class="outline-text-3" id="text-orgcfb4276">
<ol class="org-ol">
<li>Chargez les données <code>Wine</code> dans un <code>DataFrame</code> nommé <code>data_wine_ori_df</code> (<code>ori</code> pour originales).</li>

<li>Créez le <code>DataFrame</code> <code>data_wine_df</code> correspondant aux données <code>Wine</code> centrées et réduites.
<b>Note:</b> On rappelle que l'étape de centrage et de réduction n'est pas obligatoire pour faire un
partitionnement. En revanche, ce traitement est ici utile pour limiter l'influence de l'echelle
de certaines variables.</li>

<li><p>
Réaliser une Analyse en Composantes Principales (ACP) sur les données <code>data_wine_df</code> en analysant rapidement le résultat obtenu. Aide :
utilisez la classe <code>PCA</code> du <i>package</i> <code>sklearn.decomposition</code> (ou <code>skd</code> pour nous). 
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">data_wine_acp</span> = skd.PCA().fit(data_wine_df)
<span style="color: #DFAF8F;">data_wine_acp_df</span> = pd.DataFrame(data_wine_acp.transform(data_wine_df), 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   columns=[f<span style="color: #CC9393;">"X{i+1}"</span> <span style="color: #F0DFAF; font-weight: bold;">for</span> i <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">range</span>(<span style="color: #DCDCCC; font-weight: bold;">len</span>(data_wine_df.columns))])
data_wine_acp_df.head()
</pre>
</div></li>

<li><p>
Créez un <code>DataFrame</code> <code>data_wine_acp_2d_df</code> correspondant aux données
<code>Wine</code> projetées sur les deux premiers axes de l'ACP.
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">data_wine_acp_2d_df</span> = &lt;&#224; compl&#233;ter&gt;
</pre>
</div></li>

<li><p>
Représentez graphiquement le nuage de points des données <code>data_wine_acp_2d_df</code>.
</p>
<div class="org-src-container">
<pre class="src src-python">px.scatter(&lt;&#224; compl&#233;ter&gt;
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>  title=<span style="color: #CC9393;">"Projection des donn&#233;es sur les deux premiers axes de l'ACP"</span>)
</pre>
</div></li>
</ol>
</div>
</div>


<div id="outline-container-org0e4c8af" class="outline-3">
<h3 id="org0e4c8af">Moyennes mobiles</h3>
<div class="outline-text-3" id="text-org0e4c8af">
<ol class="org-ol">
<li><p>
Appliquez l'algorithme des moyennes mobiles sur les données en recherchant \(K=3\) groupes en
utilisant les paramètres par défaut. On notera <code>km_1</code> ce premier "modèle" de <i>clustering</i>.
</p>
<ul class="org-ul">
<li>Aide : utilisez la classe <a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html"><code>KMeans</code></a> du package <code>sklearn.cluster</code> (ou <code>skc</code> pour nous).</li>
<li>Prenez le temps de bien comprendre le fonctionnement et les concepts de la librairie
<code>scikit-learn</code> associés aux  algorithmes de classification (méthode <code>fit</code>, entrées/sorties,
etc.).</li>
</ul>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">km_1</span> = skc.KMeans(n_clusters=3)
km_1.fit(data_wine_acp_2d_df)
&lt;Analysez le contenu de l<span style="color: #CC9393;">'objet km_1&gt;</span>
</pre>
</div></li>

<li>Représentez graphiquement la partition obtenue avec le modèle <code>km_1</code>.</li>

<li>Créez une fonction <code>eval_partition</code> ayant les caractéristiques suivantes :
<ul class="org-ul">
<li>Entrées :
<ul class="org-ul">
<li>des données quantitatives sous forme de <code>DataFrame</code> <code>Pandas</code> ;</li>
<li>une partition sous forme de <code>Series</code> <code>Pandas</code>.</li>
</ul></li>
<li>Retourne :
<ul class="org-ul">
<li>l'inertie intra-classe de la partition dans le cas de données équipondérées de poids 1 ;</li>
<li>le pourcentage d'inertie expliquée par la partition.</li>
</ul></li>
</ul></li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">eval_partition</span>(data_df, partition):
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #9FC59F;">"""</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;"> Entr&#233;es :</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;"> - data_df (pandas.DataFrame) : Donn&#233;es quantitatives</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;"> - partition (list, numpy.array ou pandas.Series) : partition des donn&#233;es</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;"> Sortie :</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;"> - inertie_intra : inertie intra-classe de la partition</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;"> - inertie_score : Inertie expliqu&#233;e par la partition entre 0 et 1</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span><span style="color: #9FC59F;"> """</span>

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul de l'inertie totale des donn&#233;es (cf. TD1)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> &lt;&#224; compl&#233;ter&gt;
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #DFAF8F;">inertie_totale</span> = &lt;&#224; compl&#233;ter&gt;

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul de l'inertie interne aux classes (cf. TD1)</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #DFAF8F;">inertie_intra</span> = 0
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #F0DFAF; font-weight: bold;">for</span> cls, data_cls_df <span style="color: #F0DFAF; font-weight: bold;">in</span> data_df.groupby(partition):
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   &lt;&#224; compl&#233;ter&gt;
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">inertie_intra</span> += &lt;&#224; compl&#233;ter&gt;

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Inertie expliqu&#233;e par la partition</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #DFAF8F;">inertie_score</span> = &lt;&#224; compl&#233;ter&gt;

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #F0DFAF; font-weight: bold;">return</span> inertie_intra, inertie_score
</pre>
</div>

<ol class="org-ol">
<li>Utilisez votre fonction <code>eval_partition</code> sur la partition du modèle <code>km_1</code> et comparez avec les résultats
obtenus par la classe <code>KMeans</code>.</li>

<li>Réalisez un second modèle <code>km_2</code> :
<ul class="org-ul">
<li>utilisez une initialisation aléatoire contrôlée en fixant le paramètre <code>random_state</code> à la valeur
<code>12345</code> ;</li>
<li>l'algorithme ne doit tester qu'une initialisation, cf. paramètre <code>n_init</code> ;</li>
<li>représentez graphiquement la partition obtenue ;</li>
<li>comparez les résultats avec ceux du modèle <code>km_1</code>.</li>
</ul></li>

<li>Lancez la méthode <code>KMeans</code> en faisant varier le nombre de classes et représentez graphiquement les pourcentages
d'inertie expliqué correspondants. Quel est selon vous le nombre de classes pertinent pour ces
données ?</li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">M&#233;thode du coude</span>
<span style="color: #DFAF8F;">inertie_intra</span> = []
<span style="color: #DFAF8F;">K_list</span> = <span style="color: #DCDCCC; font-weight: bold;">range</span>(2, 50)
<span style="color: #F0DFAF; font-weight: bold;">for</span> k <span style="color: #F0DFAF; font-weight: bold;">in</span> K_list:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> &lt;&#224; compl&#233;ter&gt;
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #DFAF8F;">iintra</span>, <span style="color: #DFAF8F;">iscore</span> = eval_partition(data_wine_acp_2d_df, 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> &lt;&#224; compl&#233;ter&gt;)
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> inertie_intra.append(iintra)

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Repr&#233;sentation graphique des r&#233;sultats</span>
px.line(x=K_list, y=inertie_intra, 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   title=<span style="color: #CC9393;">"Inertie intra-classe vs nb de classes (m&#233;thode du coude)"</span>,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   width=500, height=500)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc229302" class="outline-3">
<h3 id="orgc229302">Mélange gaussien</h3>
<div class="outline-text-3" id="text-orgc229302">
<ol class="org-ol">
<li>Estimez un modèle gaussien à trois classes sur les données en utilisant les paramètres par
défaut. Ce modèle sera notée <code>gmm_1</code>. Aide : utilisez la classe <a href="https://scikit-learn.org/stable/modules/generated/sklearn.mixture.GaussianMixture.html">classe
<code>GaussianMixture</code> </a>du package <code>sklearn.mixture</code> (ou <code>skm</code> pour nous).</li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">gmm_1</span> = skm.GaussianMixture(n_components=3)
gmm_1.fit(data_wine_acp_2d_df)
</pre>
</div>

<ol class="org-ol">
<li>Affichez les paramètres du modèle <code>gmm_1</code>. Aide : consultez les attributs <code>means_</code>,
<code>covariances_</code>, <code>weights_</code>.</li>

<li>Calculez la partition des données <code>data_wine_acp_2d_df</code> à partir du modèle <code>gmm_1</code>.</li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #DFAF8F;">gmm_1_cls_pred</span> = gmm_1.predict(data_wine_acp_2d_df)
</pre>
</div>

<ol class="org-ol">
<li>Représenter graphiquement la partition <code>gmm_1_cls_pred</code>.</li>

<li>Comparez vos résultats avec les partitions obtenues avec les moyennes mobiles. Que constatez vous ?</li>

<li>Adaptez à la méthode des mélanges le principe de la méthode du coude vue pour le choix du nombre
de classes dans le cas des moyennes mobiles. Aide : utilisez l'attribut <code>bic</code> comme critère de
qualité sans oublier bien sûr de comprendre à quoi correspond ce critère.</li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">M&#233;thode du coude</span>
<span style="color: #DFAF8F;">score</span> = []
<span style="color: #DFAF8F;">K_list</span> = <span style="color: #DCDCCC; font-weight: bold;">range</span>(2, 50)
<span style="color: #F0DFAF; font-weight: bold;">for</span> k <span style="color: #F0DFAF; font-weight: bold;">in</span> K_list:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #DFAF8F;">gmm_k_test</span> = &lt;&#224; compl&#233;ter&gt;
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> score.append(gmm_k_test.bic(data_wine_acp_2d_df))

<span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Repr&#233;sentation graphique des r&#233;sultats</span>
px.line(x=K_list, y=score, 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   title=<span style="color: #CC9393;">"BIC vs nb de classes (m&#233;thode du coude)"</span>,
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   width=500, height=500)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3f30fb0" class="outline-2">
<h2 id="org3f30fb0">Exercice 2 : Données synthétiques</h2>
<div class="outline-text-2" id="text-org3f30fb0">
<p>
Afin de mieux appréhender les propriétés des différentes méthodes de partitionnement, nous allons
utiliser des données générées pour lesquelles nous avons contrôlé la forme de la distribution des
groupes. 
</p>

<p>
Nous pourrons ainsi évaluer les avantages et les limitations des méthodes sur des données dont on
maîtrise le partitionnement <i>a priori</i>.
</p>
</div>

<div id="outline-container-org8a59c2f" class="outline-3">
<h3 id="org8a59c2f">Données circulaires</h3>
<div class="outline-text-3" id="text-org8a59c2f">
<ol class="org-ol">
<li>Chargez les données <code>data_circ.csv</code> à partir de l'adresse :
<a href="https://roland-donat.github.io/cours-class-non-sup/td/td2/data_circ.csv">https://roland-donat.github.io/cours-class-non-sup/td/td2/data_circ.csv</a>. Le séparateur utilisé
est le ";".</li>

<li>Visualisez les données. Combien de groupes identifiez vous ? Faites un résumé statistique visuel
des groupes.</li>

<li>Appliquez un partitionnement avec la méthode des moyennes mobiles et affichez le résultat.</li>

<li>Appliquez un partitionnement avec un mélange gaussien et affichez le résultat.</li>

<li>Évaluez les deux partitionnements obtenus et interprétez les résultats.</li>
</ol>
</div>
</div>

<div id="outline-container-org4baddc1" class="outline-3">
<h3 id="org4baddc1">Données elliptiques</h3>
<div class="outline-text-3" id="text-org4baddc1">
<ol class="org-ol">
<li>Chargez les données <code>data_ellipse.csv</code> à partir de l'adresse :
<a href="https://roland-donat.github.io/cours-class-non-sup/td/td2/data_ellipse.csv">https://roland-donat.github.io/cours-class-non-sup/td/td2/data_ellipse.csv</a>. Le séparateur utilisé
est le ";".</li>

<li>Visualisez les données. Combien de groupes identifiez vous ? Faites un résumé statistique visuel
des groupes.</li>

<li>Appliquez un partitionnement avec la méthode des moyennes mobiles et affichez le résultat.</li>

<li>Appliquez un partitionnement avec un mélange gaussien et affichez le résultat.</li>

<li>Évaluez les deux partitionnements obtenus et interprétez les résultats.</li>

<li>Appliquez de nouveau la méthode du mélange gaussien en modifiant le paramètre
<code>covariance_type</code>. Visualisez et interprétez les résultats.</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org618a8a9" class="outline-2">
<h2 id="org618a8a9">Exercice 3 : Implémentation des moyennes mobiles</h2>
<div class="outline-text-2" id="text-org618a8a9">
<p>
Comme on ne maîtrise jamais vraiment un algorithme tant que l'on ne l'a pas programmé, cette
dernière partie propose de créer votre propre version de la méthode des moyennes mobiles.
</p>

<p>
Pour ce faire, il vous faudra créer les trois fonctions suivantes :
</p>

<ol class="org-ol">
<li>La fonction <code>calcule_centres</code> qui calcule le centre de chaque classe à partir de données
quantitative et d'une partition.</li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">calcule_centres</span>(data, partition):
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> &lt;&#224; compl&#233;ter&gt;

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #F0DFAF; font-weight: bold;">return</span> centres
</pre>
</div>

<ol class="org-ol">
<li>La fonction <code>affecte_classe</code> qui prend en entrée des données et les centres des classes et qui
affecte à chaque individu la classe ayant le centre le plus proche au sens de la distance euclidienne.</li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">affecte_classe</span>(data, centres):

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> &lt;&#224; compl&#233;ter&gt;

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #F0DFAF; font-weight: bold;">return</span> partition
</pre>
</div>

<ol class="org-ol">
<li>La fonction <code>mon_kmeans</code> qui prend en entrée des données et un nombre de classes et qui applique
la méthode des moyennes mobiles. L'initialisation est supposée aléatoire et on arrêtera
l'algorithme dès que la partition construite n'évolue plus entre deux itérations.</li>
</ol>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">my_kmeans</span>(data, K):
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Partition initiale</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #DFAF8F;">partition</span> = np.random.choice(K, <span style="color: #DCDCCC; font-weight: bold;">len</span>(data))
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #DFAF8F;">critere_arret</span> = <span style="color: #BFEBBF;">False</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> 
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #F0DFAF; font-weight: bold;">while</span> critere_arret:
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Affectation des classes</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">centres</span> = &lt;&#224; compl&#233;ter&gt;

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul des nouveaux centres</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">partition</span> = &lt;&#224; compl&#233;ter&gt;
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">Calcul du crit&#232;re d'arr&#234;t</span>
<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span>   <span style="color: #DFAF8F;">critere_arret</span> = &lt;&#224; compl&#233;ter&gt;

<span style="color: #DCDCCC; background-color: #4F4F4F;"> </span> <span style="color: #F0DFAF; font-weight: bold;">return</span> partition, centres
</pre>
</div>

<ol class="org-ol">
<li>Utilisez votre algorithme sur les données des exercices précédents et comparez vos résultats avec
la méthode <code>KMeans</code> de <code>scikit-learn</code>.</li>
</ol>
</div>
</div>
</div>
</body>
</html>
